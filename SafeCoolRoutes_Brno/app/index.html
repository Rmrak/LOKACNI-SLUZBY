<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Safe & Cool Routes Brno ‚Äì Demo v2</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body, #map { height: 100%; margin: 0; padding: 0; }
  .controls {
    position: absolute; top: 10px; left: 10px; z-index: 1000;
    background: white; padding: 10px; border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3); font-family: system-ui, sans-serif; font-size: 14px;
    max-width: 250px;
  }
  .legend {
    position: absolute; bottom: 10px; left: 10px; z-index: 1000;
    background: white; padding: 10px; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    font-family: system-ui, sans-serif; font-size: 12px;
  }
  button, select { margin-top: 6px; width: 100%; padding: 5px; box-sizing: border-box; }
  label { display: block; margin-top: 4px; }
  .badge { display: inline-block; padding: 2px 6px; border-radius: 3px; background: #eee; margin-left: 6px; font-weight: bold;}
  #status { position:absolute;top:10px;right:10px;z-index:1000;background:rgba(255,255,255,0.8);
            padding:8px 10px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,0.3);font-family:system-ui,sans-serif;font-size:12px; }
  a.small { font-size:12px; margin-left:6px; color: #555; }
  #metrics { font-size: 11px; margin-top: 8px; line-height: 1.6; }
  #metrics span.badge { min-width: 30px; text-align: center; display: inline-block; }
</style>
</head>
<body>
<div class="controls">
  <div><strong>Safe & Cool Routes ‚Äì Brno</strong>
    <a class="small" href="health.html" target="_blank">diagnostika</a>
  </div>
  <div>Re≈æim trasy:</div>
  <select id="routeType">
    <option value="length_m">üìè Nejkrat≈°√≠</option>
    <option value="risk_cost">üõ°Ô∏è Bezpeƒçnƒõj≈°√≠</option>
    <option value="heat_cost">üå≥ V√≠c ve st√≠nu</option>
  </select>
  <button id="startBtn">üìç Nastavit START (klik do mapy)</button>
  <button id="destBtn">üèÅ Nastavit C√çL (klik do mapy)</button>
  <button id="goBtn" disabled>Napl√°novat trasu</button>
  <div style="margin-top:6px; border-top: 1px solid #eee; padding-top: 6px;">
    <label><input type="checkbox" id="toggleHazards" checked> Rizikov√° m√≠sta</label>
    <label><input type="checkbox" id="toggleCool" checked> Chladn√° m√≠sta</label>
    <label><input type="checkbox" id="toggleSchools" checked> Vstupy do ≈°kol</label>
    <label><input type="checkbox" id="toggleLights" > Ve≈ô. osvƒõtlen√≠ (mƒõsto)</label>
    <label><input type="checkbox" id="toggleGreenery" > Zele≈à (mƒõsto)</label>
    <label><input type="checkbox" id="toggleGrid" > S√≠≈• (debug)</label>
  </div>
  <div id="metrics">Zvolte start a c√≠l...</div>
</div>
<div id="status">Naƒç√≠t√°m data...</div>
<div id="map"></div>
<div class="legend">
  <div><strong>Legenda</strong></div>
  <div>üî¥ Riziko | üîµ Cool | üè´ ≈†kola | <span style="color: #ff0;">‚óè</span> VO | <span style="color: #070;">‚óè</span> Zele≈à</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([49.195, 16.608], 13); // Centered on Brno
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
}).addTo(map);

let startPoint=null, destPoint=null, settingStart=false, settingDest=false;
const startMarker = L.marker([0,0], {draggable: true, opacity:0});
const destMarker  = L.marker([0,0], {draggable: true, opacity:0});
const routeLayer = L.geoJSON(null, {style: {weight:5, color: '#3388ff', opacity: 0.8}}).addTo(map);
const gridLayer  = L.layerGroup(); // Initially not added to map

startMarker.on('dragend', function(e) { startPoint = e.target.getLatLng(); checkPlanButton(); });
destMarker.on('dragend', function(e) { destPoint = e.target.getLatLng(); checkPlanButton(); });

// === Vrstvy ===
// T√Ωmov√© vrstvy ‚Äì lok√°ln√≠ fallback
const hazardsLayer = L.geoJSON(null, {
  pointToLayer: (f, latlng) => L.circleMarker(latlng, {radius:5, weight:1, color:'#c00', fillColor:'#c00', fillOpacity:0.7})
    .bindTooltip(`Riziko: ${f.properties.type || 'N/A'} (Z√°va≈ænost: ${f.properties.severity || 'N/A'})`)
});
const coolLayer = L.geoJSON(null, {
  pointToLayer: (f, latlng) => L.circleMarker(latlng, {radius:5, weight:1, color:'#06c', fillColor:'#06c', fillOpacity:0.7})
    .bindTooltip(`Cool Spot: ${f.properties.type || 'N/A'} (Kvalita st√≠nu: ${f.properties.shade_quality || 'N/A'})`)
});
const schoolsLayer = L.geoJSON(null, {
  pointToLayer: (f, latlng) => L.marker(latlng, { icon: L.divIcon({className: 'school-icon', html: 'üè´', iconSize: [20, 20]})})
    .bindTooltip(`${f.properties.school_name || '≈†kola'}`)
});

// Mƒõstsk√© vrstvy (budou naplnƒõny pozdƒõji)
const streetLightingLayer = L.geoJSON(null, {
  pointToLayer: (f, latlng) => L.circleMarker(latlng, {radius:2, weight:0, color:'#ff0', fillColor:'#ff0', fillOpacity:0.6})
    .bindTooltip('Ve≈ôejn√© osvƒõtlen√≠')
});
const greeneryLayer = L.geoJSON(null, { // Zjednodu≈°en√© zobrazen√≠
    pointToLayer: (f, latlng) => L.circleMarker(latlng, {radius:3, weight:0, color:'#070', fillColor:'#070', fillOpacity:0.6}),
    style: { color: '#070', weight: 1, opacity: 0.5, fillOpacity: 0.1 }
}).bindTooltip('Zele≈à');

// === Ovl√°dac√≠ prvky ===
const startBtn = document.getElementById('startBtn');
const destBtn = document.getElementById('destBtn');
const goBtn = document.getElementById('goBtn');
const statusDiv = document.getElementById('status');
const metricsDiv = document.getElementById('metrics');

function updateButtonStyles() {
    startBtn.style.fontWeight = settingStart ? 'bold' : 'normal';
    startBtn.style.backgroundColor = settingStart ? '#dff' : '';
    destBtn.style.fontWeight = settingDest ? 'bold' : 'normal';
    destBtn.style.backgroundColor = settingDest ? '#dff' : '';
}

function checkPlanButton() {
    goBtn.disabled = !(startPoint && destPoint && graph);
    if (!goBtn.disabled) {
        metricsDiv.innerHTML = "P≈ôipraveno k pl√°nov√°n√≠.";
    } else if (!graph) {
         metricsDiv.innerHTML = "ƒåek√°m na naƒçten√≠ s√≠tƒõ...";
    } else {
         metricsDiv.innerHTML = "Zvolte start a c√≠l...";
    }
}

startBtn.onclick = () => { settingStart = true; settingDest = false; updateButtonStyles(); map.getContainer().style.cursor = 'crosshair'; };
destBtn.onclick = () => { settingDest = true; settingStart = false; updateButtonStyles(); map.getContainer().style.cursor = 'crosshair'; };
goBtn.onclick    = () => { planRoute(); };

map.on('click', (e) => {
  if (settingStart) {
    startPoint = e.latlng;
    startMarker.setLatLng(startPoint).setOpacity(1).addTo(map).bindPopup("<b>Start</b><br/>P≈ôesu≈à pro √∫pravu.").openPopup();
    settingStart = false;
  } else if (settingDest) {
    destPoint  = e.latlng;
    destMarker.setLatLng(destPoint).setOpacity(1).addTo(map).bindPopup("<b>C√≠l</b><br/>P≈ôesu≈à pro √∫pravu.").openPopup();
    settingDest = false;
  }
  updateButtonStyles();
  checkPlanButton();
  map.getContainer().style.cursor = '';
});

// P≈ôep√≠naƒçe vrstev
document.getElementById('toggleHazards').onchange = e => e.target.checked ? map.addLayer(hazardsLayer) : map.removeLayer(hazardsLayer);
document.getElementById('toggleCool').onchange    = e => e.target.checked ? map.addLayer(coolLayer) : map.removeLayer(coolLayer);
document.getElementById('toggleSchools').onchange = e => e.target.checked ? map.addLayer(schoolsLayer) : map.removeLayer(schoolsLayer);
document.getElementById('toggleLights').onchange = e => e.target.checked ? map.addLayer(streetLightingLayer) : map.removeLayer(streetLightingLayer);
document.getElementById('toggleGreenery').onchange = e => e.target.checked ? map.addLayer(greeneryLayer) : map.removeLayer(greeneryLayer);
document.getElementById('toggleGrid').onchange    = e => { if (e.target.checked) { if(graph) renderGrid(); map.addLayer(gridLayer); } else map.removeLayer(gridLayer); };


// === Pomocn√© funkce ===
function haversine(lat1, lon1, lat2, lon2) {
  const R=6371000.0, toRad=d=>d*Math.PI/180;
  const phi1=toRad(lat1), phi2=toRad(lat2), dphi=toRad(lat2-lat1), dl=toRad(lon2-lon1);
  const a = Math.sin(dphi/2)**2 + Math.cos(phi1)*Math.cos(phi2)*Math.sin(dl/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

// === S√≠≈• a Routing ===
let graph=null, nodesById=null, adj=null;

function renderGrid() {
  gridLayer.clearLayers();
  if (!graph || !nodesById) return;
  for (const e of graph.edges) {
    const a = nodesById[e.from], b = nodesById[e.to];
    // Check if nodes exist before drawing
    if (a && b) {
       L.polyline([[a.lat,a.lon],[b.lat,b.lon]], {weight:1, color:'#ccc', opacity:0.3}).addTo(gridLayer);
    } else {
       console.warn(`Missing node for edge ${e.id}: from=${e.from}, to=${e.to}`);
    }
  }
}

function nearestNode(lat, lon) {
  let best=null, bestd=Infinity;
  if (!graph || !graph.nodes) return null;
  for (const n of graph.nodes) {
    const d=haversine(lat,lon,n.lat,n.lon);
    if (d<bestd) { bestd=d; best=n; }
  }
  return best;
}

// Funkce pro v√Ωpoƒçet v√°hy hrany (vylep≈°en√°)
function calculateEdgeWeight(edge, weightKey, nodesById) {
    let baseWeight = edge.length_m;
    if (baseWeight <= 0) baseWeight = 1; // Minim√°ln√≠ v√°ha, aby se zabr√°nilo dƒõlen√≠ nulou

    const nodeFrom = nodesById[edge.from];
    const nodeTo = nodesById[edge.to];
    if (!nodeFrom || !nodeTo) return baseWeight * 100; // Penalizace za chybƒõj√≠c√≠ uzel

    const edgeLat = (nodeFrom.lat + nodeTo.lat) / 2;
    const edgeLon = (nodeFrom.lon + nodeTo.lon) / 2;
    const edgeCenter = L.latLng(edgeLat, edgeLon);

    // --- Safety Score / Risk Cost ---
    let safetyPenalty = 0;
    const MAX_DIST_HAZARD = 50; // metry
    const MAX_DIST_LIGHT = 40;  // metry
    const HAZARD_SEVERITY_MULTIPLIER = 15; // Jak moc z√°va≈ænost zvy≈°uje penalizaci
    const HAZARD_PROXIMITY_FACTOR = 0.5;   // Jak moc bl√≠zkost zvy≈°uje penalizaci
    const LIGHT_DISTANCE_FACTOR = 0.3;   // Jak moc vzd√°lenost od svƒõtla zvy≈°uje penalizaci

    hazardsLayer.eachLayer(layer => {
        if (layer.getLatLng) {
            const dist = edgeCenter.distanceTo(layer.getLatLng());
            if (dist < MAX_DIST_HAZARD) {
                safetyPenalty += (layer.feature.properties.severity || 1) * HAZARD_SEVERITY_MULTIPLIER * (MAX_DIST_HAZARD - dist) * HAZARD_PROXIMITY_FACTOR;
            }
        }
    });

    let minLightDist = Infinity;
    streetLightingLayer.eachLayer(layer => {
        if (layer.getLatLng) {
            const dist = edgeCenter.distanceTo(layer.getLatLng());
            minLightDist = Math.min(minLightDist, dist);
        }
     });
     if (minLightDist > MAX_DIST_LIGHT && minLightDist !== Infinity) {
        safetyPenalty += (minLightDist - MAX_DIST_LIGHT) * LIGHT_DISTANCE_FACTOR * baseWeight; // V√°ha roste s d√©lkou tmav√©ho √∫seku
     } else if (minLightDist === Infinity && streetLightingLayer.getLayers().length > 0) {
        // Pokud jsou svƒõtla naƒçtena, ale ≈æ√°dn√© nen√≠ bl√≠zko
        safetyPenalty += 50 * LIGHT_DISTANCE_FACTOR * baseWeight; // Pau≈°√°ln√≠ penalizace
     }

    // Normalizace risk cost (0-100, 100 = nejhor≈°√≠) - velmi zjednodu≈°en√°
    let calculatedRiskCost = Math.min(100, Math.max(0, safetyPenalty / (baseWeight * 0.5 + 1))); // Normalizace vzhledem k d√©lce

    // --- Heat Comfort Score / Heat Cost ---
    let heatBenefit = 0;
    const MAX_DIST_COOL = 100; // metry
    const MAX_DIST_GREEN = 50; // metry
    const COOL_SHADE_MULTIPLIER = 10;
    const COOL_PROXIMITY_FACTOR = 0.4;
    const GREEN_PROXIMITY_FACTOR = 0.3;

    coolLayer.eachLayer(layer => {
        if (layer.getLatLng) {
            const dist = edgeCenter.distanceTo(layer.getLatLng());
            if (dist < MAX_DIST_COOL) {
                heatBenefit += (layer.feature.properties.shade_quality || 1) * COOL_SHADE_MULTIPLIER * (MAX_DIST_COOL - dist) * COOL_PROXIMITY_FACTOR;
            }
        }
    });

    greeneryLayer.eachLayer(layer => {
        let featureCenter;
        try { // Ochrana proti chyb√°m v geometrii
          if (layer.getLatLng) { featureCenter = layer.getLatLng(); }
          else if (layer.getBounds) { featureCenter = layer.getBounds().getCenter(); }
        } catch (e) { /* ignore */ }

        if (featureCenter) {
            const dist = edgeCenter.distanceTo(featureCenter);
             if (dist < MAX_DIST_GREEN) {
                 heatBenefit += (MAX_DIST_GREEN - dist) * GREEN_PROXIMITY_FACTOR * baseWeight; // V√°ha benefitu roste s d√©lkou
             }
        }
     });

    // Normalizace heat cost (0-100, 100 = nejteplej≈°√≠) - velmi zjednodu≈°en√°
    let calculatedHeatScore = Math.min(100, Math.max(0, heatBenefit / (baseWeight * 0.2 + 1))); // Normalizace benefitu
    let calculatedHeatCost = 100 - calculatedHeatScore;

    // --- V√Ωsledn√° v√°ha ---
    // Koeficienty zde urƒçuj√≠, jak moc se penalizace/benefity projev√≠ oproti d√©lce. NUTNO LADIT!
    const RISK_WEIGHT_FACTOR = 0.05; // Jak moc risk_cost ovlivn√≠ v√°hu
    const HEAT_WEIGHT_FACTOR = 0.05; // Jak moc heat_cost ovlivn√≠ v√°hu
    const BASE_WEIGHT_FACTOR = 0.01; // Jak moc z√°kladn√≠ d√©lka ovlivn√≠ v√°hu (sn√≠≈æeno, aby vynikly costy)

    if (weightKey === 'risk_cost') {
        return (calculatedRiskCost * RISK_WEIGHT_FACTOR * baseWeight) + (baseWeight * BASE_WEIGHT_FACTOR);
    } else if (weightKey === 'heat_cost') {
        return (calculatedHeatCost * HEAT_WEIGHT_FACTOR * baseWeight) + (baseWeight * BASE_WEIGHT_FACTOR);
    } else { // length_m
        return baseWeight;
    }
}


function dijkstra(startId, goalId, weightKey) {
  if (!graph || !adj || !nodesById) return []; // Check if graph data is loaded
  const dist = {}; dist[startId] = 0;
  const prev = {};
  const heap = [[0, startId]]; // Prioritn√≠ fronta jako pole [v√°ha, id_uzlu]
  const visited = new Set();

  // Helper pro prioritn√≠ frontu (jednoduch√° implementace)
  function heapPush(item) { heap.push(item); heap.sort((a, b) => a[0] - b[0]); }
  function heapPop() { return heap.shift(); }

  while(heap.length > 0){
    const [currentDist, u] = heapPop();

    if (visited.has(u)) continue; // Pokud u≈æ byl uzel fin√°lnƒõ zpracov√°n
    visited.add(u);

    if(u === goalId) break; // C√≠l nalezen

    if(currentDist > (dist[u] ?? Infinity)) continue; // P≈ôeskoƒçen√≠ zastaral√Ωch z√°znam≈Ø ve frontƒõ

    for(const edge of adj[u] || []){
      const v = edge.to;
      if (visited.has(v)) continue; // P≈ôeskoƒçen√≠ ji≈æ nav≈°t√≠ven√Ωch soused≈Ø

      // Dynamick√Ω v√Ωpoƒçet v√°hy hrany
      const weight = calculateEdgeWeight(edge, weightKey, nodesById);
      if (weight === Infinity) continue; // Skip impassable edges

      const newDist = currentDist + weight;

      if(newDist < (dist[v] ?? Infinity)){
         dist[v] = newDist;
         prev[v] = edge; // Ulo≈æ√≠me si hranu, kterou jsme p≈ôi≈°li
         heapPush([newDist, v]);
       }
    }
  }

  // Rekonstrukce cesty
  const pathEdges = [];
  let currentId = goalId;
  while(currentId !== startId){
     const edge = prev[currentId];
     if(!edge) return []; // Cesta nenalezena
     pathEdges.push(edge);
     currentId = edge.from;
  }
  return pathEdges.reverse(); // Otoƒç√≠me pole hran do spr√°vn√©ho po≈ôad√≠
}

function pathToGeoJSON(pathEdges){
  const coords = [];
  let totalLength = 0;
  let totalWeightedRiskCost = 0;
  let totalWeightedHeatCost = 0;

  if (pathEdges.length === 0) {
      return {"type":"Feature", "properties":{}, "geometry":{"type":"LineString","coordinates":[]}};
  }

  // P≈ôid√°me poƒç√°teƒçn√≠ bod
  const firstNode = nodesById[pathEdges[0].from];
  if (firstNode) {
     coords.push([firstNode.lon, firstNode.lat]);
  } else {
     console.error("Missing node for start of path:", pathEdges[0].from);
     return null; // Chyba - nelze sestavit GeoJSON
  }


  for(const e of pathEdges){
    const toNode = nodesById[e.to];
    if (toNode) {
       coords.push([toNode.lon, toNode.lat]);
    } else {
       console.error("Missing node for path edge:", e.to);
       continue; // Pokraƒçujeme, i kdy≈æ chyb√≠ uzel, ale cesta bude ne√∫pln√°
    }

    const edgeLength = e.length_m > 0 ? e.length_m : 1;
    totalLength += edgeLength;

    // Znovu vypoƒç√≠t√°me "ƒçist√©" costy pro metriky (bez n√°soben√≠ d√©lkou a BASE_WEIGHT_FACTOR)
    let edgeRiskCost = calculateEdgeWeight(e, 'risk_cost', nodesById) / (edgeLength * 0.05 + 0.01) ; // Odhad
    let edgeHeatCost = calculateEdgeWeight(e, 'heat_cost', nodesById) / (edgeLength * 0.05 + 0.01); // Odhad
    totalWeightedRiskCost += Math.min(100, Math.max(0, edgeRiskCost)) * edgeLength;
    totalWeightedHeatCost += Math.min(100, Math.max(0, edgeHeatCost)) * edgeLength;
  }

  const avgRiskCost = (totalLength > 0) ? (totalWeightedRiskCost / totalLength) : 0;
  const avgHeatCost = (totalLength > 0) ? (totalWeightedHeatCost / totalLength) : 0;
  const avgSafetyScore = (100 - avgRiskCost).toFixed(1);
  const avgHeatScore = (100 - avgHeatCost).toFixed(1);


  return {
    "type":"Feature",
    "properties":{
        "length_m": Math.round(totalLength),
        "avg_safety_score": avgSafetyScore,
        "avg_heat_score": avgHeatScore
    },
    "geometry":{
        "type":"LineString",
        "coordinates":coords
    }
  };
}

function planRoute(){
  if(!startPoint || !destPoint){ alert("Nejd≈ô√≠ve kliknut√≠m do mapy nastavte START a C√çL."); return; }
  if(!graph){ alert("S√≠≈• (graph) je≈°tƒõ nen√≠ naƒçtena."); return; }

  statusDiv.innerHTML = "Hled√°m trasu...";
  metricsDiv.innerHTML = "Poƒç√≠t√°m...";

  // Pot≈ôebujeme naj√≠t nejbli≈æ≈°√≠ uzly v na≈°√≠ s√≠ti k bod≈Øm start/c√≠l
  const startNode = nearestNode(startPoint.lat, startPoint.lng);
  const destNode = nearestNode(destPoint.lat, destPoint.lng);

  if (!startNode || !destNode) {
      alert("Nepoda≈ôilo se naj√≠t nejbli≈æ≈°√≠ body v s√≠ti.");
      statusDiv.innerHTML = "Chyba p≈ôi hled√°n√≠.";
      return;
  }

  // Mal√° vizu√°ln√≠ √∫prava - p≈ôesun znaƒçek na nejbli≈æ≈°√≠ uzly (voliteln√©)
  // startMarker.setLatLng([startNode.lat, startNode.lon]);
  // destMarker.setLatLng([destNode.lat, destNode.lon]);

  const routeType = document.getElementById('routeType').value;

  // Pou≈æit√≠ setTimeout, aby se status "Hled√°m trasu..." stihl zobrazit p≈ôed v√Ωpoƒçtem
  setTimeout(() => {
      const path = dijkstra(startNode.id, destNode.id, routeType);

      routeLayer.clearLayers();
      if(path.length === 0){
        alert("Trasa mezi zvolen√Ωmi body nebyla nalezena.");
        statusDiv.innerHTML = "Trasa nenalezena.";
        metricsDiv.innerHTML = "Trasa nenalezena.";
        return;
      }

      const gj = pathToGeoJSON(path);
      if (gj) {
          routeLayer.addData(gj);
          map.fitBounds(routeLayer.getBounds().pad(0.1)); // Zoom na trasu

          statusDiv.innerHTML = "Trasa nalezena.";
          metricsDiv.innerHTML =
            `D√©lka: <span class="badge">${gj.properties.length_m} m</span><br/>
             Avg Safety Score: <span class="badge">${gj.properties.avg_safety_score}/100</span><br/>
             Avg Heat Score: <span class="badge">${gj.properties.avg_heat_score}/100</span>`;
      } else {
          statusDiv.innerHTML = "Chyba p≈ôi tvorbƒõ GeoJSON.";
          metricsDiv.innerHTML = "Chyba zobrazen√≠ trasy.";
      }
  }, 50); // Kr√°tk√° pauza pro UI update
}

// === Naƒç√≠t√°n√≠ dat ===
let dataPromises = []; // Pole pro sledov√°n√≠ v≈°ech fetch request≈Ø

statusDiv.innerHTML = 'Naƒç√≠t√°m s√≠≈•...';

// 1) Naƒçti s√≠≈• (Graph)
const graphPromise = fetch('data/Graph_Grid_Brno.json')
 .then(r=>{ if(!r.ok) throw new Error(`Chyba p≈ôi naƒç√≠t√°n√≠ s√≠tƒõ: ${r.status}`); return r.json(); })
 .then(g=>{
    graph=g;
    nodesById={};
    adj={};
    // Indexace uzl≈Ø podle ID
    for(const n of graph.nodes) {
       nodesById[n.id]=n;
    }
    // Vytvo≈ôen√≠ seznamu soused≈Ø (adjacency list)
    for(const e of graph.edges){
       if(!adj[e.from]) adj[e.from]=[];
       adj[e.from].push(e);
       // Pokud je graf neorientovan√Ω, p≈ôidat i opaƒçnou hranu, pokud neexistuje
       // U na≈°eho gridu jsou hrany obousmƒõrn√© definovan√© explicitnƒõ
    }
    if (document.getElementById('toggleGrid').checked) renderGrid(); // Vykresli grid, pokud je zapnut√Ω
    statusDiv.innerHTML='S√≠≈• naƒçtena ‚úì';
    checkPlanButton(); // Zkontrolovat, zda lze pl√°novat
    console.log(`Graph loaded: ${graph.nodes.length} nodes, ${graph.edges.length} edges.`);
 })
 .catch(e=>{
    console.error("Nepoda≈ôilo se naƒç√≠st s√≠≈•:", e);
    statusDiv.innerHTML='Chyba naƒç√≠t√°n√≠ s√≠tƒõ ‚úó';
    alert('Kritick√° chyba: Nepoda≈ôilo se naƒç√≠st soubor s√≠tƒõ (Graph_Grid_Brno.json). Aplikace nem≈Ø≈æe pl√°novat trasy.');
 });
dataPromises.push(graphPromise);

// Pomocn√° funkce pro naƒç√≠t√°n√≠ GeoJSON s fallbackem
function loadGeoJsonLayer(layer, url, fallbackUrl, name, addToMap = true) {
    const mainFetch = fetch(url)
        .then(r => {
            if (!r.ok) {
                 console.warn(`Chyba naƒç√≠t√°n√≠ ${name} z ${url} (${r.status}), zkou≈°√≠m fallback: ${fallbackUrl}`);
                 if (fallbackUrl) return fetch(fallbackUrl);
                 else throw new Error(`HTTP ${r.status}`);
             }
             return r;
        })
        .then(r => {
             if (!r.ok) throw new Error(`Fallback ${name} z ${fallbackUrl} selhal (${r.status})`);
             return r.json();
        })
        .then(gj => {
            layer.addData(gj);
            if (addToMap) layer.addTo(map);
            console.log(`Layer loaded: ${name} (${gj.features?.length || 0} features)`);
            return true; // Signal success
        })
        .catch(e => {
            console.error(`Nepoda≈ôilo se naƒç√≠st vrstvu ${name}:`, e);
            statusDiv.innerHTML += ` Chyba ${name} ‚úó`;
            return false; // Signal failure
        });
     dataPromises.push(mainFetch);
}


// Naƒçti konfiguraci a spus≈• vrstvy
statusDiv.innerHTML = 'Naƒç√≠t√°m konfiguraƒçn√≠ soubor...';
fetch('layers.city.json')
  .then(r => { if (!r.ok) throw new Error('layers.city.json nenalezen'); return r.json(); })
  .then(cfg => {
    statusDiv.innerHTML = 'Naƒç√≠t√°m vrstvy...';

    // 2) T√Ωmov√© vrstvy
    const team = cfg.team_datasets || {};
    loadGeoJsonLayer(hazardsLayer, team.hazards?.url, 'data/HazardObservations_Brno.geojson', 'Hazards', document.getElementById('toggleHazards').checked);
    loadGeoJsonLayer(coolLayer, team.coolspots?.url, 'data/CoolSpots_Brno.geojson', 'CoolSpots', document.getElementById('toggleCool').checked);
    loadGeoJsonLayer(schoolsLayer, team.school_entrances?.url, 'data/SchoolEntrances_Brno.geojson', 'Schools', document.getElementById('toggleSchools').checked);

    // 3) ≈Ωiv√° mƒõstsk√° data (dle configu)
    const live = cfg.city_portal_live || {};
    // P≈ô√≠klad naƒçten√≠ VO - P≈òIDAT DO CFG, pokud nen√≠
    if (live.street_lighting_poles?.url) {
        loadGeoJsonLayer(streetLightingLayer, live.street_lighting_poles.url, null, 'StreetLights', document.getElementById('toggleLights').checked);
    } else {
        console.warn("URL pro Street Lighting nen√≠ v layers.city.json");
    }
     // P≈ô√≠klad naƒçten√≠ Zelenƒõ - P≈òIDAT DO CFG, pokud nen√≠
    if (live.urban_greenery_trees?.url) { // Pou≈æ√≠v√°me stromy jako proxy pro zele≈à
        loadGeoJsonLayer(greeneryLayer, live.urban_greenery_trees.url, null, 'Greenery', document.getElementById('toggleGreenery').checked);
    } else {
        console.warn("URL pro Urban Greenery nen√≠ v layers.city.json");
    }
    // Dal≈°√≠ mƒõstsk√© vrstvy (p≈ôechody, chodn√≠ky, hluk...) lze naƒç√≠st podobnƒõ, pokud je pot≈ôebujeme zobrazit
    // loadGeoJsonLayer(L.geoJSON().bindPopup('P≈ôechod'), live.pedestrian_crossings?.url, null, 'Crossings', false); // P≈ô√≠klad - nenaƒç√≠tat na mapu defaultnƒõ

    // 4) Extern√≠ (voliteln√©) ‚Äì GeoJSON (uk√°zkov√° data)
    const extLocal = cfg.external_local || {};
    if (extLocal.chmi_air_quality?.url) {
        loadGeoJsonLayer(L.geoJSON(null, {pointToLayer:(f,l)=>L.circleMarker(l,{radius:4,color:'#a0f'})}).bindTooltip('Air Quality'), extLocal.chmi_air_quality.url, null, 'AirQuality (local)', false);
    }
     if (extLocal.csuz_census_2021?.url) {
        loadGeoJsonLayer(L.geoJSON(null, {style:{color:'#0a0', weight:1, fillOpacity:0.1}}).bindTooltip('Census Data'), extLocal.csuz_census_2021.url, null, 'Census (local)', false);
     }

    // Poƒçk√°me na dokonƒçen√≠ v≈°ech naƒç√≠t√°n√≠
    Promise.all(dataPromises).then(results => {
       const allLoaded = results.every(res => res !== false); // Zkontrolujeme, zda se v≈°e naƒçetlo (nebo byl pou≈æit fallback)
       if (allLoaded && graph) {
           statusDiv.innerHTML = 'V≈°echna data naƒçtena ‚úì';
       } else if (graph) {
           statusDiv.innerHTML = 'S√≠≈• naƒçtena, nƒõkter√© vrstvy chyb√≠.';
       } else {
            statusDiv.innerHTML = 'Chyba naƒç√≠t√°n√≠ dat ‚úó';
       }
       checkPlanButton(); // Fin√°ln√≠ kontrola tlaƒç√≠tka pl√°nov√°n√≠
    });

  })
  .catch(e => {
    console.error("Chyba p≈ôi zpracov√°n√≠ layers.city.json:", e);
    statusDiv.innerHTML = 'Chyba konfigurace ‚úó';
    // Pokud sel≈æe config, zkus√≠me naƒç√≠st aspo≈à lok√°ln√≠ t√Ωmov√° data
    loadGeoJsonLayer(hazardsLayer, 'data/HazardObservations_Brno.geojson', null, 'Hazards (fallback)');
    loadGeoJsonLayer(coolLayer, 'data/CoolSpots_Brno.geojson', null, 'CoolSpots (fallback)');
    loadGeoJsonLayer(schoolsLayer, 'data/SchoolEntrances_Brno.geojson', null, 'Schools (fallback)');
    Promise.all(dataPromises).finally(() => checkPlanButton()); // I po fallbacku zkontrolovat
  });

</script>
</body>
</html>
